import Foundation
import Network

// MARK: - Aeron Compatible Publication (‰∏éaeron-rsÂÆåÂÖ®ÂÖºÂÆπ)

public class AeronCompatiblePublication {
    private let streamId: UInt32
    private let sessionId: UInt32
    private let initialTermId: UInt32
    private let termBufferLength: Int
    private let positionBitsToShift: Int
    
    private let connection: NWConnection
    private let queue: DispatchQueue
    private var isConnected = false
    
    // Term buffers - ÊåâÁÖßAeronËßÑËåÉ‰ΩøÁî®Âçï‰∏™Ê¥ªÂä®ÊúØËØ≠
    private var termOffset: UInt32 = 0
    private var currentTermId: UInt32
    
    // Flow control
    private var receiverWindow: UInt32 = 0
    private var lastStatusMessageTime = Date()
    
    public init(streamId: UInt32, sessionId: UInt32, termBufferLength: Int = AeronProtocolSpec.TERM_DEFAULT_LENGTH, host: String, port: UInt16) {
        self.streamId = streamId
        self.sessionId = sessionId
        self.initialTermId = UInt32.random(in: 1...UInt32.max) // ÈöèÊú∫ÂàùÂßãÊúØËØ≠ID
        self.currentTermId = self.initialTermId
        self.termBufferLength = termBufferLength
        self.positionBitsToShift = AeronProtocolSpec.positionBitsToShift(termBufferLength: termBufferLength)
        
        // ÂàõÂª∫UDPËøûÊé•
        let endpoint = NWEndpoint.hostPort(
            host: NWEndpoint.Host(host),
            port: NWEndpoint.Port(rawValue: port)!
        )
        
        self.connection = NWConnection(to: endpoint, using: .udp)
        self.queue = DispatchQueue(label: "aeron-compatible-publication")
    }
    
    public func connect() async throws {
        print("üîå ËøûÊé•Âà∞AeronÂÖºÂÆπÁ´ØÁÇπ: \(streamId):\(sessionId)")
        
        return try await withCheckedThrowingContinuation { continuation in
            var hasResumed = false
            
            connection.stateUpdateHandler = { state in
                switch state {
                case .ready:
                    self.isConnected = true
                    if !hasResumed {
                        hasResumed = true
                        continuation.resume()
                    }
                    Task {
                        await self.sendSetupFrame()
                        await self.startStatusMessageHandler()
                    }
                case .failed(let error):
                    if !hasResumed {
                        hasResumed = true
                        continuation.resume(throwing: error)
                    }
                case .cancelled:
                    if !hasResumed {
                        hasResumed = true
                        continuation.resume(throwing: AeronError.connectionCancelled)
                    }
                default:
                    break
                }
            }
            
            connection.start(queue: queue)
        }
    }
    
    // MARK: - Setup Frame (Âª∫Á´ãËøûÊé•)
    
    private func sendSetupFrame() async {
        let setupHeader = AeronSetupHeader(
            sessionId: sessionId,
            streamId: streamId,
            initialTermId: initialTermId,
            termLength: UInt32(termBufferLength)
        )
        
        let setupData = setupHeader.toBytes()
        await sendUDPFrame(setupData)
        print("üìã ÂèëÈÄÅSetupÂ∏ß: ÊµÅ\(streamId), ‰ºöËØù\(sessionId), ÂàùÂßãÊúØËØ≠\(initialTermId)")
    }
    
    // MARK: - Data Publication (ÊåâÁÖßAeronËßÑËåÉ)
    
    public func offer(_ buffer: Data) async -> Int64 {
        guard isConnected else { return -1 }
        
        let messageLength = buffer.count
        let frameLength = AeronProtocolSpec.DATA_HEADER_LENGTH + messageLength
        let alignedFrameLength = alignFrameLength(frameLength)
        
        // Ê£ÄÊü•ÊúØËØ≠ÁºìÂÜ≤Âå∫Á©∫Èó¥
        if Int(termOffset) + alignedFrameLength > termBufferLength {
            // ËΩÆÊç¢Âà∞‰∏ã‰∏Ä‰∏™ÊúØËØ≠
            currentTermId += 1
            termOffset = 0
        }
        
        // ÂàõÂª∫Êï∞ÊçÆÂ∏ßÂ§¥
        let dataHeader = AeronDataHeader(
            frameLength: UInt32(frameLength),
            termOffset: termOffset,
            sessionId: sessionId,
            streamId: streamId,
            termId: currentTermId
        )
        
        // ÊûÑÂª∫ÂÆåÊï¥Â∏ß
        var frame = dataHeader.toBytes()
        frame.append(buffer)
        
        // Â°´ÂÖÖÂà∞ÂØπÈΩêËæπÁïå
        let paddingNeeded = alignedFrameLength - frameLength
        if paddingNeeded > 0 {
            frame.append(Data(repeating: 0, count: paddingNeeded))
        }
        
        await sendUDPFrame(frame)
        
        // Êõ¥Êñ∞ÊúØËØ≠ÂÅèÁßª
        termOffset += UInt32(alignedFrameLength)
        
        // ËÆ°ÁÆó‰ΩçÁΩÆ
        let position = AeronProtocolSpec.computePosition(
            termId: Int32(currentTermId - initialTermId),
            termOffset: Int32(termOffset),
            positionBitsToShift: positionBitsToShift
        )
        
        return position
    }
    
    // MARK: - Status Message Handling (ÊµÅÊéßÂà∂)
    
    private func startStatusMessageHandler() async {
        // ÁõëÂê¨Áä∂ÊÄÅÊ∂àÊÅØÁî®‰∫éÊµÅÊéßÂà∂
        receiveStatusMessages()
    }
    
    private func receiveStatusMessages() {
        connection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { data, _, isComplete, error in
            if let data = data, !data.isEmpty {
                Task {
                    await self.handleStatusMessage(data)
                }
            }
            
            if let error = error {
                print("‚ùå Êé•Êî∂Áä∂ÊÄÅÊ∂àÊÅØÈîôËØØ: \(error)")
                return
            }
            
            if !isComplete {
                self.receiveStatusMessages()
            }
        }
    }
    
    private func handleStatusMessage(_ data: Data) async {
        guard data.count >= AeronProtocolSpec.STATUS_MESSAGE_HEADER_LENGTH else { return }
        
        let type = UInt16.fromLittleEndianBytes(data, offset: 6)
        
        if type == AeronProtocolSpec.SM_HEADER_TYPE {
            // Ëß£ÊûêÁä∂ÊÄÅÊ∂àÊÅØ
            let sessionId = UInt32.fromLittleEndianBytes(data, offset: 8)
            let streamId = UInt32.fromLittleEndianBytes(data, offset: 12)
            let consumptionTermId = UInt32.fromLittleEndianBytes(data, offset: 16)
            let consumptionTermOffset = UInt32.fromLittleEndianBytes(data, offset: 20)
            let receiverWindow = UInt32.fromLittleEndianBytes(data, offset: 24)
            
            if sessionId == self.sessionId && streamId == self.streamId {
                self.receiverWindow = receiverWindow
                self.lastStatusMessageTime = Date()
                print("üìä Êî∂Âà∞Áä∂ÊÄÅÊ∂àÊÅØ: Á™óÂè£=\(receiverWindow), ÊúØËØ≠=\(consumptionTermId), ÂÅèÁßª=\(consumptionTermOffset)")
            }
        }
    }
    
    // MARK: - Utility Methods
    
    private func alignFrameLength(_ length: Int) -> Int {
        return (length + AeronProtocolSpec.FRAME_ALIGNMENT - 1) & ~(AeronProtocolSpec.FRAME_ALIGNMENT - 1)
    }
    
    private func sendUDPFrame(_ frame: Data) async {
        do {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                connection.send(content: frame, completion: .contentProcessed { error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume()
                    }
                })
            }
        } catch {
            print("‚ùå ÂèëÈÄÅÂ∏ßÂ§±Ë¥•: \(error)")
        }
    }
    
    public func close() {
        connection.cancel()
        isConnected = false
    }
    
    public func getPosition() -> Int64 {
        return AeronProtocolSpec.computePosition(
            termId: Int32(currentTermId - initialTermId),
            termOffset: Int32(termOffset),
            positionBitsToShift: positionBitsToShift
        )
    }
}

// MARK: - Aeron Compatible Subscription (‰∏éaeron-rsÂÆåÂÖ®ÂÖºÂÆπ)

public class AeronCompatibleSubscription {
    private let streamId: UInt32
    private let sessionId: UInt32?  // nilË°®Á§∫ËÆ¢ÈòÖÊâÄÊúâ‰ºöËØù
    
    private let listener: NWListener
    private let queue: DispatchQueue
    private var isListening = false
    
    // Êé•Êî∂Áä∂ÊÄÅË∑üË∏™
    private var publications: [UInt32: PublicationState] = [:] // sessionId -> state
    private var lastPositions: [UInt32: Int64] = [:]
    
    // Fragment handler
    public var fragmentHandler: ((Data, UInt32, UInt32, Int64) -> Void)?
    
    struct PublicationState {
        var initialTermId: UInt32
        var termBufferLength: Int
        var positionBitsToShift: Int
        var lastTermId: UInt32
        var lastTermOffset: UInt32
        var receivedFrames: Set<String> = [] // Èò≤ÈáçÂ§ç
        
        init(initialTermId: UInt32, termBufferLength: Int) {
            self.initialTermId = initialTermId
            self.termBufferLength = termBufferLength
            self.positionBitsToShift = AeronProtocolSpec.positionBitsToShift(termBufferLength: termBufferLength)
            self.lastTermId = initialTermId
            self.lastTermOffset = 0
        }
    }
    
    public init(streamId: UInt32, sessionId: UInt32? = nil, port: UInt16) throws {
        self.streamId = streamId
        self.sessionId = sessionId
        
        let parameters = NWParameters.udp
        parameters.allowLocalEndpointReuse = true
        
        self.listener = try NWListener(using: parameters, on: NWEndpoint.Port(rawValue: port)!)
        self.queue = DispatchQueue(label: "aeron-compatible-subscription")
    }
    
    public func startListening() async throws {
        print("üéß ÂêØÂä®AeronÂÖºÂÆπËÆ¢ÈòÖ: ÊµÅ\(streamId), Á´ØÂè£\(listener.port!)")
        
        listener.newConnectionHandler = { connection in
            self.handleConnection(connection)
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            listener.stateUpdateHandler = { state in
                switch state {
                case .ready:
                    self.isListening = true
                    continuation.resume()
                case .failed(let error):
                    continuation.resume(throwing: error)
                case .cancelled:
                    continuation.resume(throwing: AeronError.connectionCancelled)
                default:
                    break
                }
            }
            
            listener.start(queue: queue)
        }
    }
    
    public func stopListening() {
        listener.cancel()
        isListening = false
    }
    
    private func handleConnection(_ connection: NWConnection) {
        connection.start(queue: queue)
        receiveFrames(from: connection)
    }
    
    private func receiveFrames(from connection: NWConnection) {
        connection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { data, _, isComplete, error in
            if let data = data, !data.isEmpty {
                Task {
                    await self.processFrame(data, connection: connection)
                }
            }
            
            if let error = error {
                print("‚ùå Êé•Êî∂Â∏ßÈîôËØØ: \(error)")
                return
            }
            
            if !isComplete {
                self.receiveFrames(from: connection)
            }
        }
    }
    
    private func processFrame(_ data: Data, connection: NWConnection) async {
        guard data.count >= 8 else { return } // ÊúÄÂ∞èÂ∏ßÂ§¥
        
        let frameLength = UInt32.fromLittleEndianBytes(data, offset: 0)
        let type = UInt16.fromLittleEndianBytes(data, offset: 6)
        
        switch type {
        case AeronProtocolSpec.SETUP_HEADER_TYPE:
            await handleSetupFrame(data, connection: connection)
            
        case AeronProtocolSpec.DATA_HEADER_TYPE:
            await handleDataFrame(data, connection: connection)
            
        default:
            print("‚ö†Ô∏è Êú™Áü•Â∏ßÁ±ªÂûã: \(type)")
        }
    }
    
    private func handleSetupFrame(_ data: Data, connection: NWConnection) async {
        guard data.count >= AeronProtocolSpec.SETUP_HEADER_LENGTH else { return }
        
        let sessionId = UInt32.fromLittleEndianBytes(data, offset: 12)
        let streamId = UInt32.fromLittleEndianBytes(data, offset: 16)
        let initialTermId = UInt32.fromLittleEndianBytes(data, offset: 20)
        let termLength = Int(UInt32.fromLittleEndianBytes(data, offset: 28))
        
        // Ê£ÄÊü•ÊòØÂê¶ÊòØÊàë‰ª¨ÊÑüÂÖ¥Ë∂£ÁöÑÊµÅ
        guard streamId == self.streamId else { return }
        if let targetSessionId = self.sessionId, targetSessionId != sessionId { return }
        
        // ÂàõÂª∫ÊàñÊõ¥Êñ∞ÂèëÂ∏ÉÁä∂ÊÄÅ
        publications[sessionId] = PublicationState(
            initialTermId: initialTermId,
            termBufferLength: termLength
        )
        
        print("üìã Êî∂Âà∞SetupÂ∏ß: ÊµÅ\(streamId), ‰ºöËØù\(sessionId), ÂàùÂßãÊúØËØ≠\(initialTermId), ÊúØËØ≠ÈïøÂ∫¶\(termLength)")
        
        // ÂèëÈÄÅÂàùÂßãÁä∂ÊÄÅÊ∂àÊÅØ
        await sendStatusMessage(to: connection, sessionId: sessionId, streamId: streamId, termId: initialTermId, termOffset: 0)
    }
    
    private func handleDataFrame(_ data: Data, connection: NWConnection) async {
        guard let dataHeader = AeronDataHeader.fromBytes(data) else { return }
        
        // Ê£ÄÊü•ÊµÅÂíå‰ºöËØùÂåπÈÖç
        guard dataHeader.streamId == self.streamId else { return }
        if let targetSessionId = self.sessionId, targetSessionId != dataHeader.sessionId { return }
        
        guard var pubState = publications[dataHeader.sessionId] else {
            print("‚ö†Ô∏è Êî∂Âà∞Êï∞ÊçÆÂ∏ß‰ΩÜÊ≤°ÊúâÂØπÂ∫îÁöÑSetup: ‰ºöËØù\(dataHeader.sessionId)")
            return
        }
        
        // Èò≤ÈáçÂ§çÊ£ÄÊü•
        let frameKey = "\(dataHeader.termId):\(dataHeader.termOffset)"
        if pubState.receivedFrames.contains(frameKey) {
            print("üîÑ ÈáçÂ§çÂ∏ß: \(frameKey)")
            return
        }
        pubState.receivedFrames.insert(frameKey)
        
        // ÊèêÂèñÊúâÊïàËΩΩËç∑
        let payloadOffset = AeronProtocolSpec.DATA_HEADER_LENGTH
        guard data.count > payloadOffset else { return }
        
        let payload = data.subdata(in: payloadOffset..<Int(dataHeader.frameLength))
        
        // ËÆ°ÁÆó‰ΩçÁΩÆ
        let relativeTermId = Int32(dataHeader.termId - pubState.initialTermId)
        let position = AeronProtocolSpec.computePosition(
            termId: relativeTermId,
            termOffset: Int32(dataHeader.termOffset),
            positionBitsToShift: pubState.positionBitsToShift
        )
        
        // Êõ¥Êñ∞Áä∂ÊÄÅ
        pubState.lastTermId = dataHeader.termId
        pubState.lastTermOffset = dataHeader.termOffset + UInt32(payload.count)
        publications[dataHeader.sessionId] = pubState
        lastPositions[dataHeader.sessionId] = position
        
        print("üì® Êî∂Âà∞Êï∞ÊçÆÂ∏ß: ‰ºöËØù\(dataHeader.sessionId), ÊúØËØ≠\(dataHeader.termId), ÂÅèÁßª\(dataHeader.termOffset), Â§ßÂ∞è\(payload.count), ‰ΩçÁΩÆ\(position)")
        
        // Ë∞ÉÁî®fragment handler
        fragmentHandler?(payload, dataHeader.sessionId, dataHeader.streamId, position)
        
        // ÂèëÈÄÅÁä∂ÊÄÅÊ∂àÊÅØÁ°ÆËÆ§
        await sendStatusMessage(
            to: connection,
            sessionId: dataHeader.sessionId,
            streamId: dataHeader.streamId,
            termId: dataHeader.termId,
            termOffset: dataHeader.termOffset + UInt32(payload.count)
        )
    }
    
    private func sendStatusMessage(to connection: NWConnection, sessionId: UInt32, streamId: UInt32, termId: UInt32, termOffset: UInt32) async {
        let statusMessage = AeronStatusMessageHeader(
            sessionId: sessionId,
            streamId: streamId,
            termId: termId,
            termOffset: termOffset,
            receiverWindow: UInt32(termBufferLength) // ËÆæÁΩÆÊé•Êî∂Á™óÂè£
        )
        
        let statusData = statusMessage.toBytes()
        
        do {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
                connection.send(content: statusData, completion: .contentProcessed { error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        continuation.resume()
                    }
                })
            }
            print("üìä ÂèëÈÄÅÁä∂ÊÄÅÊ∂àÊÅØ: ‰ºöËØù\(sessionId), ÊúØËØ≠\(termId), ÂÅèÁßª\(termOffset)")
        } catch {
            print("‚ùå ÂèëÈÄÅÁä∂ÊÄÅÊ∂àÊÅØÂ§±Ë¥•: \(error)")
        }
    }
    
    public func poll(limit: Int = 10) -> Int {
        // Âú®ÂÆûÈôÖÂÆûÁé∞‰∏≠ÔºåËøôÈáå‰ºöÂ§ÑÁêÜÁºìÂÜ≤ÁöÑÁâáÊÆµ
        // ÂΩìÂâçÂÆûÁé∞‰ΩøÁî®ÂÆûÊó∂Â§ÑÁêÜÔºåÊâÄ‰ª•ËøîÂõû0
        return 0
    }
    
    public var termBufferLength: Int {
        return AeronProtocolSpec.TERM_DEFAULT_LENGTH
    }
    
    public func getLastPosition(sessionId: UInt32) -> Int64? {
        return lastPositions[sessionId]
    }
}